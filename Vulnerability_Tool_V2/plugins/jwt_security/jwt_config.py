#!/usr/bin/env python3
"""
JWT Configuration Validation Plugin - Updated for NutriHelp's resolved architecture
"""

import os
import re
from typing import List, Dict, Any
from ..base_plugin import BaseSecurityPlugin, SecurityFinding


class JWTConfigurationPlugin(BaseSecurityPlugin):
    """JWT configuration verification plug-in - detection of existing basic configuration"""
    
    def get_plugin_info(self) -> Dict[str, str]:
        return {
            'name': 'JWT Configuration Validator',
            'version': '2.0.1',
            'description': 'Validates JWT security configurations (NutriHelp architecture optimized)',
            'author': 'NutriHelp Security Team'
        }
    
    def get_severity_level(self) -> str:
        return "HIGH"  
    
    def scan(self, target_path: str) -> List[SecurityFinding]:
        """Scan for JWT configuration issues"""
        self.clear_findings()

        # Check environment variable files
        self._check_env_files(target_path)

        # Check JWT implementation consistency
        self._check_jwt_implementation_consistency(target_path)

        # Check auth service configuration
        self._check_auth_service_config(target_path)

        # Check middleware configuration
        self._check_middleware_configuration(target_path)
        
        self.logger.info(f"JWT Configuration scan found {len(self.findings)} issues")
        return self.findings
    
    def _check_env_files(self, target_path: str):
        """Check environment variable configuration"""
        env_files = ['.env', '.env.example', '.env.local']
        
        for env_file in env_files:
            env_path = os.path.join(target_path, env_file)
            if os.path.exists(env_path):
                self._analyze_env_file(env_path, target_path)
    
    def _analyze_env_file(self, env_path: str, base_path: str):
        """Analyze environment variable files - Based on existing configuration checks"""
        try:
            content = self.read_file_safe(env_path)
            if not content:
                return
            
            relative_path = self.get_relative_path(env_path, base_path)
            lines = content.split('\n')
            
            jwt_secret = None
            jwt_secret_line = None
            
            # Find JWT_SECRET configuration
            for i, line in enumerate(lines, 1):
                line_clean = line.strip()
                
                if re.match(r'JWT_SECRET\s*=', line_clean):
                    jwt_secret_match = re.search(r'JWT_SECRET\s*=\s*(.+)', line_clean)
                    if jwt_secret_match:
                        jwt_secret = jwt_secret_match.group(1).strip('\'"')
                        jwt_secret_line = i

            # Validate JWT secret strength
            if jwt_secret:
                self._validate_jwt_secret_strength(jwt_secret, jwt_secret_line, relative_path)

            # Check additional security configurations
            self._check_additional_security_config(content, relative_path)
                
        except Exception as e:
            self.logger.error(f"Error analyzing env file {env_path}: {e}")
    
    def _validate_jwt_secret_strength(self, secret: str, line_number: int, file_path: str):
        """Validate JWT secret strength"""
        min_length = self.config.get('min_secret_length', 32)
        
        secret_clean = secret.strip('\'"').strip()

        # Check length
        if len(secret_clean) < min_length:
            self.add_finding(
                title=f"JWT Secret Too Short ({len(secret_clean)} chars)",
                description=f"JWT secret is {len(secret_clean)} characters. "
                          f"Recommend at least {min_length} characters for production security.",
                file_path=file_path,
                line_number=line_number,
                severity="MEDIUM",  # Medium priority
                recommendation="Generate a stronger JWT secret using crypto.randomBytes(64).toString('hex')"
            )

        # Check entropy - Is it too simple?
        if self._is_low_entropy_secret(secret_clean):
            self.add_finding(
                title="Low Entropy JWT Secret",
                description="JWT secret appears to have low entropy (predictable patterns). "
                          "This could make the secret easier to guess.",
                file_path=file_path,
                line_number=line_number,
                severity="MEDIUM",
                recommendation="Use cryptographically secure random generation for JWT secrets."
            )
    
    def _is_low_entropy_secret(self, secret: str) -> bool:
        """Check if the secret has low entropy"""
        # Check for repeated characters
        if len(set(secret)) < len(secret) * 0.6:  # If unique characters are less than 60%
            return True

        # Check for common patterns
        patterns = [r'(.)\1{3,}', r'123', r'abc', r'qwerty']
        for pattern in patterns:
            if re.search(pattern, secret.lower()):
                return True
        
        return False
    
    def _check_additional_security_config(self, content: str, file_path: str):
        """Check additional security configurations"""
        # Check for missing other important configurations
        required_configs = {
            'SUPABASE_URL': 'Database connection configuration',
            'SUPABASE_ANON_KEY': 'Database authentication key'
        }
        
        for config_key, description in required_configs.items():
            if config_key not in content:
                self.add_finding(
                    title=f"Missing Configuration: {config_key}",
                    description=f"Required configuration {config_key} not found. "
                              f"This is needed for: {description}",
                    file_path=file_path,
                    severity="LOW",
                    recommendation=f"Add {config_key} configuration to your .env file."
                )
    
    def _check_jwt_implementation_consistency(self, target_path: str):
        """Check JWT implementation consistency"""

        # Check for two JWT middleware files
        jwt_files = [
            'authenticateToken.js',           # New version
            'middleware.js',                  # Old version
            'middleware/authenticateToken.js'
        ]
        
        found_implementations = []
        
        for jwt_file in jwt_files:
            jwt_path = os.path.join(target_path, jwt_file)
            if os.path.exists(jwt_path):
                found_implementations.append(jwt_path)
                self._analyze_jwt_implementation(jwt_path, target_path)

        # If multiple JWT implementations are found, issue a warning
        if len(found_implementations) > 1:
            self.add_finding(
                title="Multiple JWT Implementation Files Detected",
                description=f"Found {len(found_implementations)} different JWT middleware files: "
                          f"{', '.join([os.path.basename(f) for f in found_implementations])}. "
                          "This could lead to inconsistent authentication behavior.",
                file_path="Multiple files",
                severity="MEDIUM",
                recommendation="Consider consolidating to a single JWT middleware implementation "
                             "to avoid confusion and ensure consistent behavior."
            )
    
    def _analyze_jwt_implementation(self, file_path: str, base_path: str):
        """Analyze JWT implementation file - Check best practices"""
        try:
            content = self.read_file_safe(file_path)
            if not content:
                return
            
            relative_path = self.get_relative_path(file_path, base_path)
            lines = content.split('\n')

            # Check if the new authService is used
            uses_auth_service = 'authService' in content
            uses_direct_jwt = 'jwt.verify' in content
            
            if uses_direct_jwt and not uses_auth_service:
                self.add_finding(
                    title="Direct JWT Usage Instead of AuthService",
                    description=f"File {os.path.basename(file_path)} uses direct jwt.verify() "
                              "instead of the centralized authService. This bypasses your "
                              "unified authentication logic.",
                    file_path=relative_path,
                    severity="MEDIUM",
                    recommendation="Consider updating this file to use authService.verifyAccessToken() "
                                 "for consistent authentication behavior."
                )

            # Check error handling completeness
            self._check_error_handling(content, lines, relative_path)
            
        except Exception as e:
            self.logger.error(f"Error analyzing JWT implementation {file_path}: {e}")
    
    def _check_error_handling(self, content: str, lines: List[str], file_path: str):
        """Check error handling completeness"""

        # Check for appropriate error responses
        error_patterns = [
            'TokenExpiredError',
            'JsonWebTokenError', 
            'TOKEN_EXPIRED',
            'INVALID_TOKEN'
        ]
        
        has_proper_error_handling = any(pattern in content for pattern in error_patterns)
        
        if 'jwt.verify' in content and not has_proper_error_handling:
            self.add_finding(
                title="Incomplete JWT Error Handling",
                description="JWT verification code lacks comprehensive error handling. "
                          "Should handle TokenExpiredError, JsonWebTokenError, and other JWT-related errors.",
                file_path=file_path,
                severity="LOW",
                recommendation="Add comprehensive error handling for different JWT error types "
                             "to provide better user experience and security."
            )
    
    def _check_auth_service_config(self, target_path: str):
        """Check authService configuration"""
        auth_service_path = os.path.join(target_path, 'services', 'authService.js')
        
        if not os.path.exists(auth_service_path):
            return
        
        try:
            content = self.read_file_safe(auth_service_path)
            if not content:
                return
            
            relative_path = self.get_relative_path(auth_service_path, target_path)

            # Check access token expiry configuration
            access_token_pattern = r'accessTokenExpiry\s*=\s*[\'"`]([^\'"`]+)[\'"`]'
            refresh_token_pattern = r'refreshTokenExpiry\s*=\s*([^;]+);'
            
            access_match = re.search(access_token_pattern, content)
            refresh_match = re.search(refresh_token_pattern, content)
            
            if access_match:
                access_expiry = access_match.group(1)
                if access_expiry not in ['15m', '10m', '5m']:  # Recommended short-term
                    self.add_finding(
                        title=f"Long Access Token Expiry: {access_expiry}",
                        description=f"Access token expiry is set to {access_expiry}. "
                                  "For security, recommend 15 minutes or less.",
                        file_path=relative_path,
                        severity="LOW",
                        recommendation="Set access token expiry to 15m or shorter for better security."
                    )

            # Check algorithm configuration
            if 'HS256' not in content and 'algorithm' in content:
                self.add_finding(
                    title="Non-Standard JWT Algorithm",
                    description="JWT signing algorithm might not be explicitly set to HS256. "
                              "This could lead to algorithm confusion attacks.",
                    file_path=relative_path,
                    severity="LOW",
                    recommendation="Explicitly specify 'HS256' algorithm in JWT configuration."
                )
                
        except Exception as e:
            self.logger.error(f"Error analyzing auth service {auth_service_path}: {e}")
    
    def _check_middleware_configuration(self, target_path: str):
        """Check middleware configuration - Check global configuration in server.js"""
        server_path = os.path.join(target_path, 'server.js')
        
        if not os.path.exists(server_path):
            return
        
        try:
            content = self.read_file_safe(server_path)
            if not content:
                return
            
            relative_path = self.get_relative_path(server_path, target_path)

            # Check for global authentication middleware (may not be necessary, but worth a reminder)
            if 'authenticateToken' in content and 'app.use' in content:
                # If there is global JWT middleware, check if it is reasonable
                lines = content.split('\n')
                for i, line in enumerate(lines, 1):
                    if 'app.use' in line and 'authenticateToken' in line:
                        self.add_finding(
                            title="Global JWT Middleware Detected",
                            description="Found global JWT middleware in server.js. "
                                      "This will require authentication for ALL routes including public ones.",
                            file_path=relative_path,
                            line_number=i,
                            severity="HIGH",
                            recommendation="Consider using route-specific JWT middleware instead of global middleware "
                                         "to avoid blocking public endpoints."
                        )
            
        except Exception as e:
            self.logger.error(f"Error analyzing server configuration {server_path}: {e}")


# Test function
def test_plugin():
    """Test plugin basic functionality"""
    plugin = JWTConfigurationPlugin()
    
    print("Plugin Info:", plugin.get_plugin_info())
    print("Severity Level:", plugin.get_severity_level())
    print("✅ Updated JWT Configuration Plugin initialized successfully")


if __name__ == '__main__':
    test_plugin()