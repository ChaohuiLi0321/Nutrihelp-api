#!/usr/bin/env python3
"""
JWT Missing Protection Plugin - Updated for NutriHelp's actual architecture
Implementing a custom detection plugin based on existing JWT architecture
"""

import os
import re
import glob  # 添加这行
import fnmatch
from typing import List, Dict, Any
from ..base_plugin import BaseSecurityPlugin, SecurityFinding


class JWTMissingProtectionPlugin(BaseSecurityPlugin):
    """Detects API endpoints missing JWT protection - Optimized for NutriHelp's actual architecture"""
    
    def __init__(self, *args, **kwargs):  # 修改这里，添加*args, **kwargs
        super().__init__(*args, **kwargs)  # 修改这里，传递参数给父类
        self._findings_cache = set()  # 用于缓存已发现的问题

    def get_plugin_info(self) -> Dict[str, str]:
        return {
            'name': 'JWT Missing Protection Detector',
            'version': '2.0.1',
            'description': 'Detects API endpoints missing JWT authentication middleware (NutriHelp optimized)',
            'author': 'NutriHelp Security Team'
        }
    
    def get_severity_level(self) -> str:
        return "HIGH"
    
    def scan(self, target_path: str) -> List[SecurityFinding]:
        """Scan for missing JWT protection."""
        findings = []
        
        for route_file in self._find_route_files(target_path):
            self._analyze_route_file(route_file, target_path)
        
        return self.findings  # 返回收集到的所有 findings

    def _analyze_route_file(self, file_path: str, base_path: str):
        """Analyze a single route file."""
        try:
            content = self.read_file_safe(file_path)
            if not content:
                return
            
            lines = content.split('\n')
            relative_path = self.get_relative_path(file_path, base_path)

            route_patterns = [
                r'router\.(get|post|put|delete|patch)\s*\(\s*[\'"`]([^\'"`]+)[\'"`]'
            ]
            
            for i, line in enumerate(lines, 1):
                for pattern in route_patterns:
                    matches = re.finditer(pattern, line, re.IGNORECASE)
                    
                    for match in matches:
                        method = match.group(1).upper()
                        path = match.group(2)
                        
                        if not self._has_jwt_protection(line, lines, i):
                            severity = self._determine_severity(path, method, os.path.basename(file_path))
                            recommendation = self._get_recommendation(method, path)
                            
                            self.add_finding(
                                title=f"Missing JWT Protection: {method} {path}",
                                description=f"API endpoint {method} {path} in {os.path.basename(file_path)} lacks JWT authentication middleware. Based on your current architecture, this should use authenticateToken middleware.",
                                file_path=relative_path,
                                line_number=i,
                                severity=severity,
                                recommendation=recommendation
                            )
                    
        except Exception as e:
            self.logger.error(f"Error analyzing route file {file_path}: {e}")

    def _check_line_for_unprotected_routes(self, line: str, all_lines: List[str], 
                                          line_number: int, file_path: str, 
                                          route_patterns: List[str], filename: str):
        """Check for unprotected routes in a single line of code - based on existing middleware names"""
        
        for pattern in route_patterns:
            matches = re.finditer(pattern, line, re.IGNORECASE)
            
            for match in matches:
                if len(match.groups()) >= 2:
                    method = match.group(1).upper() if match.group(1) else 'USE'
                    endpoint = match.group(2)
                    
                    # Handling different endpoint formats
                    if not endpoint.startswith('/'):
                        endpoint = '/' + endpoint
                else:
                    continue

                # Skip explicitly public endpoints
                if self._is_public_endpoint(endpoint, filename):
                    continue

                # Check for JWT protection - using existing middleware names
                if not self._has_jwt_protection(line, all_lines, line_number):
                    severity = self._determine_severity(endpoint, method, filename)
                    recommendation = self._get_recommendation(endpoint, method)
                    
                    self.add_finding(
                        title=f"Missing JWT Protection: {method} {endpoint}",
                        description=f"API endpoint {method} {endpoint} in {filename} lacks JWT authentication middleware. "
                                  f"Based on your current architecture, this should use authenticateToken middleware.",
                        file_path=file_path,
                        line_number=line_number,
                        severity=severity,
                        recommendation=recommendation
                    )
    
    def _is_public_endpoint(self, endpoint: str, filename: str) -> bool:
        """Check if an endpoint should be public - based on existing route structure"""

        # Based on filename, determine public endpoints
        if filename in ['login.js', 'signup.js']:
            return True

        # Explicit public endpoints (based on existing auth.js)
        public_endpoints = [
            '/register', '/login', '/health', '/api-docs', '/docs',
            '/public', '/static', '/uploads', '/log-login', '/log-login-attempt'
        ]
        
        endpoint_lower = endpoint.lower()

        # Exact match
        if endpoint_lower in [ep.lower() for ep in public_endpoints]:
            return True

        # Prefix match
        public_prefixes = ['/public/', '/static/', '/docs/', '/uploads/', '/api-docs/']
        if any(endpoint_lower.startswith(prefix) for prefix in public_prefixes):
            return True

        # Health check endpoints
        if any(pattern in endpoint_lower for pattern in ['/health', '/ping', '/status']):
            return True
        
        return False
    
    def _has_jwt_protection(self, current_line: str, all_lines: List[str], line_number: int) -> bool:
        """Check if route has JWT protection."""
        # 预定义豁免路由
        exempt_routes = [
            '/health', 
            '/status',
            '/login',
            '/register',
            '/public',
            '/docs'
        ]
        
        # 检查是否是豁免路由
        if any(route in current_line for route in exempt_routes):
            return True
        
        # 检查上下文中的JWT保护
        context_start = max(0, line_number - 5)
        context_end = min(len(all_lines), line_number + 5)
        context = '\n'.join(all_lines[context_start:context_end])
        
        # JWT保护模式
        protection_patterns = [
            'authenticateToken',
            'requireAuth',
            'isAuthenticated',
            'checkJwt',
            'verifyToken'
        ]
        
        # 检查路由是否有JWT保护
        return any(pattern in context for pattern in protection_patterns)
    
    def _determine_severity(self, endpoint: str, method: str, filename: str) -> str:
        """Determine severity based on endpoint and method."""
        endpoint_lower = endpoint.lower()
        
        # CRITICAL - 涉及用户数据和敏感操作
        if any(sensitive in endpoint_lower for sensitive in [
            'user', 'profile', 'password', 'admin', 'token', 
            'auth', 'key', 'secret', 'credential'
        ]):
            return "CRITICAL"
        
        # HIGH - 数据修改操作
        if method in ['POST', 'PUT', 'DELETE', 'PATCH'] and not any(
            safe in endpoint_lower for safe in [
                'login', 'register', 'public', 'health'
            ]
        ):
            return "HIGH"
        
        # MEDIUM - 数据读取操作
        if method == 'GET' and any(sensitive in endpoint_lower for sensitive in [
            'user', 'data', 'profile', 'report', 'log'
        ]):
            return "MEDIUM"
        
        # LOW - 其他操作
        if method == 'GET' and any(public in endpoint_lower for public in [
            'public', 'health', 'status', 'version'
        ]):
            return "LOW"
        
        # 默认为 MEDIUM
        return "MEDIUM"

    def _get_recommendation(self, method: str, endpoint: str) -> str:
        """Generate specific recommendation."""
        return f"""To fix this JWT protection issue, add the authenticateToken middleware:

1. Import the middleware (if not already imported):
   const {{ authenticateToken }} = require('../middleware/authenticateToken');

2. Add middleware to the route:
   router.{method.lower()}('{endpoint}', authenticateToken, (req, res) => {{ ... }});
   
3. For optional authentication, you can use:
   const {{ optionalAuth }} = require('../middleware/authenticateToken');

4. Your current JWT setup uses:
   - Access tokens (15 minutes expiry)
   - Refresh tokens (7 days expiry) 
   - Proper error handling with specific error codes"""

    def _find_route_files(self, base_path: str) -> List[str]:
        """Find all route files in the project."""
        route_files = set()  # 使用集合去重
        
        # 定义要扫描的目录和文件模式
        scan_patterns = [
            'routes/*.js',           # 主路由目录
            'src/routes/*.js',       # src下的路由
            'api/routes/*.js',       # api下的路由
            '**/routes/*.js',        # 任意深度的routes目录
        ]
        
        # 定义要排除的模式
        exclude_patterns = [
            '**/node_modules/**',    # 排除node_modules
            '**/test/**',            # 排除测试文件
            '**/tests/**',
            '**/mock/**',           # 排除mock文件
            '**/*.test.js',
            '**/*.spec.js'
        ]
        
        try:
            for pattern in scan_patterns:
                full_pattern = os.path.join(base_path, pattern)
                matches = glob.glob(full_pattern, recursive=True)
                
                # 过滤排除的文件
                filtered_matches = [
                    f for f in matches
                    if not any(fnmatch.fnmatch(f, os.path.join(base_path, ep)) 
                              for ep in exclude_patterns)
                ]
                
                route_files.update(filtered_matches)
        
            self.logger.info(f"Found {len(route_files)} route files to scan")
            
        except Exception as e:
            self.logger.error(f"Error finding route files: {e}")
        
        return list(route_files)

    def _cache_key(self, finding: dict) -> str:
        """Generate a unique key for finding."""
        return f"{finding['file_path']}:{finding['line_number']}:{finding['title']}"

    def add_finding(self, **kwargs):
        """Add finding with deduplication."""
        cache_key = self._cache_key(kwargs)
        
        if cache_key not in self._findings_cache:
            self._findings_cache.add(cache_key)
            self.findings.append(SecurityFinding(**kwargs))

    def generate_recommendation(self, route_info: dict) -> str:
        """Generate specific recommendation based on route info"""
        method = route_info['method']
        path = route_info['path']
        file_name = os.path.basename(route_info.get('file_path', ''))

        # 为不同类型的路由生成具体的建议
        if 'user' in path.lower() or 'profile' in path.lower():
            return f"""This endpoint ({method} {path}) handles user data and requires strong authentication:

1. Import the JWT middleware:
   const {{ authenticateToken }} = require('../middleware/authenticateToken');

2. Add strict authentication:
   router.{method.lower()}('{path}', authenticateToken, (req, res) => {{
     // Verify user ID matches authenticated user
     if (req.user.id !== req.params.userId) {{
       return res.status(403).json({{ error: 'Unauthorized access' }});
     }}
     // ... rest of your code
   }});"""

        elif method in ['POST', 'PUT', 'DELETE']:
            return f"""This endpoint ({method} {path}) modifies data and requires authentication:

1. Import the JWT middleware:
   const {{ authenticateToken }} = require('../middleware/authenticateToken');

2. Add authentication to protect data modification:
   router.{method.lower()}('{path}', authenticateToken, yourController);

3. Verify request in controller:
   function yourController(req, res) {{
     // Ensure user has required permissions
     if (!req.user.permissions.includes('{path.split("/")[1]}')) {{
       return res.status(403).json({{ error: 'Insufficient permissions' }});
     }}
     // ... rest of your code
   }}"""

        else:
            return f"""Add JWT authentication to protect this endpoint:

1. Import the middleware:
   const {{ authenticateToken }} = require('../middleware/authenticateToken');

2. Add middleware to route:
   router.{method.lower()}('{path}', authenticateToken, (req, res) => {{ ... }});

3. Consider using optional authentication if this is a public endpoint:
   const {{ optionalAuth }} = require('../middleware/authenticateToken');
   router.{method.lower()}('{path}', optionalAuth, (req, res) => {{ ... }});"""


# Test function
def test_plugin():
    """Test plugin basic functionality"""
    plugin = JWTMissingProtectionPlugin()
    
    print("Plugin Info:", plugin.get_plugin_info())
    print("Severity Level:", plugin.get_severity_level())
    print("✅ Updated JWT Missing Protection Plugin initialized successfully")


if __name__ == '__main__':
    test_plugin()