#!/usr/bin/env python3
"""
JWT Missing Protection Plugin - Updated for NutriHelp's actual architecture
Implementing a custom detection plugin based on existing JWT architecture
"""

import os
import re
from typing import List, Dict, Any
from ..base_plugin import BaseSecurityPlugin, SecurityFinding


class JWTMissingProtectionPlugin(BaseSecurityPlugin):
    """Detects API endpoints missing JWT protection - Optimized for NutriHelp's actual architecture"""
    
    def get_plugin_info(self) -> Dict[str, str]:
        return {
            'name': 'JWT Missing Protection Detector',
            'version': '2.0.1',
            'description': 'Detects API endpoints missing JWT authentication middleware (NutriHelp optimized)',
            'author': 'NutriHelp Security Team'
        }
    
    def get_severity_level(self) -> str:
        return "HIGH"
    
    def scan(self, target_path: str) -> List[SecurityFinding]:
        """Scan for missing JWT protection issues in target paths"""
        self.clear_findings()

        # Scan routes directory
        routes_path = os.path.join(target_path, 'routes')
        
        if not os.path.exists(routes_path):
            self.logger.warning(f"Routes directory not found: {routes_path}")
            return self.findings
        
        self.logger.info(f"Scanning routes directory: {routes_path}")

        # Traverse all route files
        for root, dirs, files in os.walk(routes_path):
            for file in files:
                if file.endswith('.js'):
                    file_path = os.path.join(root, file)
                    self._analyze_route_file(file_path, target_path)
        
        self.logger.info(f"JWT Missing Protection scan found {len(self.findings)} issues")
        return self.findings
    
    def _analyze_route_file(self, file_path: str, base_path: str):
        """Analyze a single route file - Based on existing route structure"""
        try:
            content = self.read_file_safe(file_path)
            if not content:
                return
            
            lines = content.split('\n')
            relative_path = self.get_relative_path(file_path, base_path)

            # Based on existing code, detect different route definition patterns
            route_patterns = [
                # Express router ( auth.js, recipe.js )
                r'router\.(get|post|put|delete|patch)\s*\(\s*[\'"`]([^\'"`]+)[\'"`]',
                # App.use ( index.js )
                r'app\.use\s*\(\s*[\'"`]([^\'"`]+)[\'"`]',
                # Controller direct call
                r'router\.(get|post|put|delete|patch)\s*\(\s*[\'"`]([^\'"`]+)[\'"`]\s*,\s*[^,]*controller'
            ]
            
            for i, line in enumerate(lines, 1):
                self._check_line_for_unprotected_routes(
                    line, lines, i, relative_path, route_patterns, os.path.basename(file_path)
                )
                
        except Exception as e:
            self.logger.error(f"Error analyzing route file {file_path}: {e}")
    
    def _check_line_for_unprotected_routes(self, line: str, all_lines: List[str], 
                                          line_number: int, file_path: str, 
                                          route_patterns: List[str], filename: str):
        """Check for unprotected routes in a single line of code - based on existing middleware names"""
        
        for pattern in route_patterns:
            matches = re.finditer(pattern, line, re.IGNORECASE)
            
            for match in matches:
                if len(match.groups()) >= 2:
                    method = match.group(1).upper() if match.group(1) else 'USE'
                    endpoint = match.group(2)
                    
                    # Handling different endpoint formats
                    if not endpoint.startswith('/'):
                        endpoint = '/' + endpoint
                else:
                    continue

                # Skip explicitly public endpoints
                if self._is_public_endpoint(endpoint, filename):
                    continue

                # Check for JWT protection - using existing middleware names
                if not self._has_jwt_protection(line, all_lines, line_number):
                    severity = self._determine_severity(endpoint, method, filename)
                    recommendation = self._get_recommendation(endpoint, method)
                    
                    self.add_finding(
                        title=f"Missing JWT Protection: {method} {endpoint}",
                        description=f"API endpoint {method} {endpoint} in {filename} lacks JWT authentication middleware. "
                                  f"Based on your current architecture, this should use authenticateToken middleware.",
                        file_path=file_path,
                        line_number=line_number,
                        severity=severity,
                        recommendation=recommendation
                    )
    
    def _is_public_endpoint(self, endpoint: str, filename: str) -> bool:
        """Check if an endpoint should be public - based on existing route structure"""

        # Based on filename, determine public endpoints
        if filename in ['login.js', 'signup.js']:
            return True

        # Explicit public endpoints (based on existing auth.js)
        public_endpoints = [
            '/register', '/login', '/health', '/api-docs', '/docs',
            '/public', '/static', '/uploads', '/log-login', '/log-login-attempt'
        ]
        
        endpoint_lower = endpoint.lower()

        # Exact match
        if endpoint_lower in [ep.lower() for ep in public_endpoints]:
            return True

        # Prefix match
        public_prefixes = ['/public/', '/static/', '/docs/', '/uploads/', '/api-docs/']
        if any(endpoint_lower.startswith(prefix) for prefix in public_prefixes):
            return True

        # Health check endpoints
        if any(pattern in endpoint_lower for pattern in ['/health', '/ping', '/status']):
            return True
        
        return False
    
    def _has_jwt_protection(self, current_line: str, all_lines: List[str], 
                           line_number: int) -> bool:
        """Check if a route has JWT protection - based on existing middleware"""
        
        # Existing JWT middleware names
        jwt_patterns = [
            'authenticateToken',  
            'optionalAuth',       
            'verifyToken',
            'jwtAuth',
            'requireAuth'
        ]
        
        # Method 1: Check current line
        for pattern in jwt_patterns:
            if re.search(rf'\b{pattern}\b', current_line, re.IGNORECASE):
                return True
        
        # Method 2: Check imports and usage
        # Check if imported from authenticateToken module
        if "require('../middleware/authenticateToken')" in current_line or \
           "require('./middleware/authenticateToken')" in current_line:

            # Check if the imported middleware is used in subsequent lines
            search_range = 10
            start_line = max(0, line_number - 1)
            end_line = min(len(all_lines), line_number + search_range)
            
            context = ' '.join(all_lines[start_line:end_line])
            for pattern in jwt_patterns:
                if pattern in context:
                    return True

        # Method 3: Check destructured import { authenticateToken }
        destructure_pattern = r'\{\s*authenticateToken\s*\}'
        if re.search(destructure_pattern, current_line):
            return True

        # Method 4: Check controller routes
        if 'controller' in current_line.lower() and any(word in current_line.lower() 
                                                       for word in ['auth', 'protected', 'secure']):
            return True
        
        return False
    
    def _determine_severity(self, endpoint: str, method: str, filename: str) -> str:
        """Determine severity by endpoint and method - based on existing logic"""
        
        endpoint_lower = endpoint.lower()

        # Based on existing route files determine critical business
        critical_files = ['userprofile.js', 'userpassword.js', 'account.js', 'medicalPrediction.js']
        high_risk_files = ['recipe.js', 'mealplan.js', 'upload.js', 'notifications.js']

        # Critical endpoint patterns
        critical_patterns = [
            '/admin', '/delete', '/remove', '/password', '/profile', 
            '/medical', '/prediction', '/account', '/payment'
        ]
        
        high_risk_patterns = [
            '/user', '/recipe', '/mealplan', '/upload', '/notification',
            '/feedback', '/preference', '/appointment'
        ]
        
        # File-level determination
        if filename in critical_files:
            return "CRITICAL"
        elif filename in high_risk_files and method in ['POST', 'PUT', 'DELETE', 'PATCH']:
            return "HIGH"
        
        # Endpoint pattern matching
        if any(pattern in endpoint_lower for pattern in critical_patterns):
            return "CRITICAL"
        elif any(pattern in endpoint_lower for pattern in high_risk_patterns):
            return "HIGH"
        elif method in ['POST', 'PUT', 'DELETE', 'PATCH']:
            return "HIGH"
        else:
            return "MEDIUM"
    
    def _get_recommendation(self, endpoint: str, method: str) -> str:
        """Get fix suggestions based on existing architecture"""
        return f"""
To fix this JWT protection issue, add the authenticateToken middleware:

1. Import the middleware (if not already imported):
   const {{ authenticateToken }} = require('../middleware/authenticateToken');

2. Add middleware to the route:
   router.{method.lower()}('{endpoint}', authenticateToken, (req, res) => {{ ... }});
   
   Or if using a controller:
   router.{method.lower()}('{endpoint}', authenticateToken, controllerFunction);

3. For optional authentication, you can use:
   const {{ optionalAuth }} = require('../middleware/authenticateToken');
   router.{method.lower()}('{endpoint}', optionalAuth, (req, res) => {{ ... }});

4. Your current JWT setup uses:
   - Access tokens (15 minutes expiry)
   - Refresh tokens (7 days expiry) 
   - Proper error handling with specific error codes

Example based on your auth.js pattern:
router.{method.lower()}('{endpoint}', authenticateToken, controllerFunction);
        """.strip()


# Test function
def test_plugin():
    """Test plugin basic functionality"""
    plugin = JWTMissingProtectionPlugin()
    
    print("Plugin Info:", plugin.get_plugin_info())
    print("Severity Level:", plugin.get_severity_level())
    print("✅ Updated JWT Missing Protection Plugin initialized successfully")


if __name__ == '__main__':
    test_plugin()