#!/usr/bin/env python3
"""General security plugin: detects common hardcoded secrets, DB connection strings,
and permissive CORS configurations.
"""
import os
import re
from typing import List, Dict, Any, Optional

from plugins.base_plugin import BaseSecurityPlugin, SecurityFinding


class GeneralSecurityPlugin(BaseSecurityPlugin):
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__(config)
        self.name = 'general_security'
        # Merge sensible defaults to reduce noisy results
        defaults = {
            'allowlist_keys': ['TEST_SECRET', 'PLACEHOLDER', 'EXAMPLE_SECRET'],
            'exclude_paths': ['tests/', '__tests__/', 'fixtures/', 'node_modules/', '.venv/', 'venv/'],
            'secret_keys_allowlist': ['password', 'passwd', 'secret', 'api_key', 'apiKey', 'token', 'jwt_secret', 'jwt']
        }
        # Only set defaults for keys not provided by user config
        for k, v in defaults.items():
            if k not in self.config:
                self.config[k] = v

    def get_plugin_info(self) -> Dict[str, str]:
        return {
            'name': 'general_security',
            'version': '0.1.0',
            'description': 'Detect generic security issues such as hardcoded secrets, DB URLs and permissive CORS.'
        }

    def get_severity_level(self) -> str:
        return 'MEDIUM'

    def scan(self, target_path: str) -> List[SecurityFinding]:
        # Walk files under target_path and perform lightweight pattern checks
        for root, dirs, files in os.walk(target_path):
            # Respect skip directories from base class config
            dirs[:] = [d for d in dirs if not self.should_skip_directory(os.path.join(root, d))]

            for fname in files:
                fpath = os.path.join(root, fname)
                # allow additional common config file extensions even if base class
                # doesn't include them (e.g., .conf, .env, .ini, .yaml, .yml, .txt)
                extra_exts = {'.conf', '.env', '.ini', '.yaml', '.yml', '.json', '.txt'}
                file_ext = os.path.splitext(fpath)[1].lower()
                if not (self.is_file_scannable(fpath) or file_ext in extra_exts):
                    continue

                content = self.read_file_safe(fpath)
                if not content:
                    continue

                # 1) hardcoded secrets (improved heuristic)
                # Require variable-like keys and a reasonably long secret value (to avoid short incidental matches)
                secret_keys = self.config.get('secret_keys_allowlist', ['password', 'passwd', 'secret', 'api_key', 'apiKey', 'token', 'jwt_secret', 'jwt'])
                secret_keys_re = r"(?:" + r"|".join([re.escape(k) for k in secret_keys]) + r")"
                # match patterns like: KEY = 'value' or "KEY": "value"; value must be at least 8 chars and not contain whitespace/newlines
                secret_pattern = re.compile(rf"(?i)({secret_keys_re})\s*[:=]\s*[\'\"]([A-Za-z0-9@#\$%\^&\-_=+\./\\~`{{}}\|]{{8,512}})[\'\"]")
                for m in secret_pattern.finditer(content):
                    key = m.group(1)
                    value = m.group(2)
                    # allowlist check: if key or file path is explicitly allowed, skip
                    allowlist_keys = [k.lower() for k in self.config.get('allowlist_keys', [])]
                    if key.lower() in allowlist_keys:
                        continue
                    exclude_paths = self.config.get('exclude_paths', [])
                    if any(p and p in fpath for p in exclude_paths):
                        continue

                    self.add_finding(
                        title=f'Hardcoded secret: {key}',
                        description=f'Found likely hardcoded secret key "{key}" in file. Value length: {len(value)}',
                        file_path=fpath,
                        line_number=self._estimate_line_number(content, m.start()),
                        severity='CRITICAL',
                        recommendation={
                            'summary': 'Remove hardcoded secrets and use environment variables or a secrets manager.',
                            'steps': [
                                'Move the secret into an environment variable or encrypted store.',
                                'Rotate the exposed secret immediately if used in production.',
                                'Ensure secrets are not committed to VCS.'
                            ]
                        }
                    )

                # 2) DB connection strings
                # match postgres://... or mysql://... regardless of surrounding quotes
                db_pattern = re.compile(r"(?i)(?:postgres(?:ql)?|mysql)://[^\s'\"`<>]+")
                for m in db_pattern.finditer(content):
                    self.add_finding(
                        title='Hardcoded DB connection string',
                        description='Found a database connection string in code or config which may contain credentials.',
                        file_path=fpath,
                        line_number=self._estimate_line_number(content, m.start()),
                        severity='HIGH',
                        recommendation='Move DB credentials to environment variables and avoid committing connection strings.'
                    )

                # 3) permissive CORS or wildcard origins (simple checks)
                # look for Access-Control-Allow-Origin: * or origin: '*' in JS/TS configs
                if re.search(r"Access-Control-Allow-Origin\s*:\s*\*", content) or re.search(r"origin\s*[:=]\s*[\'\"]\*\b", content):
                    self.add_finding(
                        title='Permissive CORS configuration',
                        description='Detected wildcard CORS origin which allows any origin to access resources.',
                        file_path=fpath,
                        line_number=None,
                        severity='MEDIUM',
                        recommendation={
                            'summary': 'Restrict CORS origins to a specific allowlist.',
                            'steps': [
                                'Replace wildcard origin with an explicit list of allowed origins.',
                                'If dynamic, validate and sanitize the Origin header before echoing it back.'
                            ]
                        }
                    )

        return self.findings

    def _estimate_line_number(self, content: str, pos: int) -> Optional[int]:
        try:
            return content[:pos].count('\n') + 1
        except Exception:
            return None
