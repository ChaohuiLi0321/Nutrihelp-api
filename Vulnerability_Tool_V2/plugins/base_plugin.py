#!/usr/bin/env python3
"""
Base plugin class for NutriHelp Security Scanner V2.0
"""

from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
import logging
import os
from datetime import datetime


class SecurityFinding:
    """Standardized security discovery objects"""
    
    def __init__(self, title: str, severity: str, file_path: str, 
                 description: str, line_number: Optional[int] = None, 
                 plugin: Optional[str] = None, recommendation: Optional[str] = None):
        self.title = title
        self.severity = severity
        self.file_path = file_path
        self.description = description
        self.line_number = line_number
        self.plugin = plugin
        self.recommendation = recommendation

    def to_dict(self) -> Dict[str, Any]:
        return {
            'title': self.title,
            'severity': self.severity,
            'file_path': self.file_path,
            'line_number': self.line_number,
            'description': self.description,
            'plugin_name': self.plugin,
            'recommendation': self.recommendation
        }


class BaseSecurityPlugin(ABC):
    """Base class for all security plugins"""

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.name = self.__class__.__name__
        self.findings: List[SecurityFinding] = []
        self.logger = logging.getLogger(f"SecurityPlugin.{self.name}")
        self._setup_logging()
    
    def _setup_logging(self):
        """Set up logging configuration"""
        if not self.logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
            handler.setFormatter(formatter)
            self.logger.addHandler(handler)
            self.logger.setLevel(logging.INFO)
    
    @abstractmethod
    def get_plugin_info(self) -> Dict[str, str]:
        """Return plugin metadata information"""
        pass
    
    @abstractmethod
    def scan(self, target_path: str) -> List[SecurityFinding]:
        """Perform security scan and return discovered issues"""
        pass
    
    @abstractmethod
    def get_severity_level(self) -> str:
        """Return default severity level for issues detected by the plugin"""
        pass
    
    def add_finding(self, title: str, description: str, file_path: str,
                   line_number: Optional[int] = None, severity: Optional[str] = None,
                   recommendation: Optional[str] = None) -> SecurityFinding:
        """Add security finding"""
        if severity is None:
            severity = self.get_severity_level()
        
        finding = SecurityFinding(
            title=title,
            severity=severity,
            file_path=file_path,
            description=description,
            line_number=line_number,
            recommendation=recommendation
        )
        finding.plugin = self.name
        self.findings.append(finding)
        
        self.logger.info(f"Added {severity} finding: {title}")
        return finding
    
    def clear_findings(self):
        """Clear all findings"""
        self.findings.clear()
    
    def is_file_scannable(self, file_path: str) -> bool:
        """Check if a file is scannable"""
        # Get supported file extensions
        supported_extensions = self.config.get('file_extensions', ['.js', '.py', '.ts'])
        file_ext = os.path.splitext(file_path)[1].lower()
        return file_ext in supported_extensions
    
    def should_skip_directory(self, dir_path: str) -> bool:
        """Check if a directory should be skipped"""
        skip_dirs = self.config.get('skip_directories', [
            'node_modules', '.git', '__pycache__', 'venv', '.venv'
        ])
        dir_name = os.path.basename(dir_path)
        return dir_name in skip_dirs
    
    def read_file_safe(self, file_path: str) -> Optional[str]:
        """Safely read file content"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except (UnicodeDecodeError, PermissionError) as e:
            self.logger.warning(f"Cannot read file {file_path}: {e}")
            return None
    
    def get_relative_path(self, file_path: str, base_path: str) -> str:
        """Get relative path"""
        try:
            return os.path.relpath(file_path, base_path)
        except ValueError:
            return file_path


class PluginManager:
    """Plugin manager"""

    def __init__(self):
        self.plugins: List[BaseSecurityPlugin] = []
        self.logger = logging.getLogger("PluginManager")
    
    def register_plugin(self, plugin: BaseSecurityPlugin):
        """Register plugin"""
        self.plugins.append(plugin)
        info = plugin.get_plugin_info()
        self.logger.info(f"Registered plugin: {info['name']} v{info['version']}")
    
    def get_plugins(self) -> List[BaseSecurityPlugin]:
        """Get all registered plugins"""
        return self.plugins
    
    def run_all_scans(self, target_path: str) -> Dict[str, List[SecurityFinding]]:
        """Run all plugin scans"""
        results = {}
        
        for plugin in self.plugins:
            plugin.clear_findings()  # Clear previous results
            try:
                findings = plugin.scan(target_path)
                results[plugin.name] = findings
                self.logger.info(f"Plugin {plugin.name} found {len(findings)} issues")
            except Exception as e:
                self.logger.error(f"Plugin {plugin.name} failed: {e}")
                results[plugin.name] = []
        
        return results