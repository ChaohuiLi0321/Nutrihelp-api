#!/usr/bin/env python3
"""
Security Scanner V2.0 - FastAPI + Swagger UI integrated
api/scanner_api.py
"""

import os
import sys
import tempfile
import asyncio
from pathlib import Path
from fastapi.responses import HTMLResponse
from typing import List, Dict, Any, Optional
from datetime import datetime

# FastAPI imports
from fastapi import FastAPI, HTTPException, BackgroundTasks, UploadFile, File
from fastapi.responses import HTMLResponse, FileResponse
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel, Field
import uvicorn

# Add scanner path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from core.scanner_engine import SecurityScannerEngine
from core.config_manager import ConfigManager
# Attempt to reuse CLI HTML generator for identical output
try:
    # scanner_v2 lives at project root
    from scanner_v2 import generate_html_report as cli_generate_html_report
    CLI_HTML_GENERATOR_AVAILABLE = True
except Exception:
    CLI_HTML_GENERATOR_AVAILABLE = False

# Shared renderer for consistent HTML output between CLI and API
try:
    from core.report_renderer import render_html_report
    SHARED_RENDERER_AVAILABLE = True
except Exception:
    SHARED_RENDERER_AVAILABLE = False


# Pydantic Models for API
class ScanRequest(BaseModel):
    """Scan request model"""
    target_path: str = Field(..., description="Target path to scan")
    plugins: Optional[List[str]] = Field(None, description="Specify plugins to use, leave empty to use all")
    output_format: str = Field("json", description="Output format: json or html")

    class Config:
        schema_extra = {
            "example": {
                "target_path": "Please enter the local path of the Nutrihelp-api folder or the path of the target to be scanned.",
                "plugins": ["JWTMissingProtectionPlugin", "JWTConfigurationPlugin"],
                "output_format": "json"
            }
        }


class ScanResult(BaseModel):
    """Scan result model"""
    scan_id: str = Field(..., description="Scan ID")
    target_path: str = Field(..., description="Target path")
    scan_time: datetime = Field(..., description="Scan time")
    total_files: int = Field(..., description="Total files scanned")
    total_findings: int = Field(..., description="Total findings")
    severity_summary: Dict[str, int] = Field(..., description="Severity-based issue statistics")
    findings: List[Dict[str, Any]] = Field(..., description="Detailed findings list")

    class Config:
        schema_extra = {
            "example": {
                "scan_id": "scan_20240906_143022",
                "target_path": "./routes",
                "scan_time": "2024-09-06T14:30:22",
                "total_files": 173,
                "total_findings": 28,
                "severity_summary": {"CRITICAL": 2, "HIGH": 16, "MEDIUM": 9, "LOW": 1},
                "findings": [
                    {
                        "title": "Missing JWT Protection",
                        "severity": "CRITICAL",
                        "file_path": "routes/userprofile.js",
                        "description": "API endpoint lacks JWT authentication middleware",
                        "recommendation": "Add authenticateToken middleware"  
                    }
                ]
            }
        }


class ScanStatus(BaseModel):
    """Scan status model"""
    scan_id: str
    status: str = Field(..., description="Scan status: running, completed, failed")
    progress: int = Field(..., description="Scan progress percentage")
    message: str = Field(..., description="Status message")


# FastAPI application initialization
app = FastAPI(
    title="NutriHelp Security Scanner V2.0",
    description="Modular security scanner API designed for the NutriHelp project",
    version="2.0.0",
    docs_url="/scanner/docs",
    redoc_url="/scanner/redoc"
)

# Global variables
scanner_engine = None
config_manager = None
active_scans = {}


@app.on_event("startup")
async def startup_event():
    """Initialize scanner on startup"""
    global scanner_engine, config_manager
    
    try:
        config_manager = ConfigManager()
        scanner_config = config_manager.get_scanner_config()
        scanner_engine = SecurityScannerEngine(scanner_config)

        # Load plugins
        plugin_configs = config_manager.get_enabled_plugins()
        scanner_engine.load_plugins(plugin_configs)
        
        print(f"✅ Security Scanner API initialized with {scanner_engine.stats['plugins_loaded']} plugins")
    except Exception as e:
        print(f"❌ Failed to initialize scanner: {e}")
        raise


@app.get("/scanner/health", tags=["Health"])
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "version": "2.0.0",
        "plugins_loaded": scanner_engine.stats['plugins_loaded'] if scanner_engine else 0,
        "timestamp": datetime.now().isoformat()
    }


@app.get("/scanner/plugins", tags=["Plugins"])
async def list_plugins():
    """Get list of available plugins"""
    if not scanner_engine:
        raise HTTPException(status_code=500, detail="Scanner engine not initialized")
    
    plugins = []
    for plugin in scanner_engine.plugin_manager.get_plugins():
        info = plugin.get_plugin_info()
        plugins.append({
            "name": info['name'],
            "version": info['version'],
            "description": info['description'],
            "severity_level": plugin.get_severity_level()
        })
    
    return {"plugins": plugins}


@app.post("/scanner/scan", response_model=Dict[str, str], tags=["Scanning"])
async def start_scan(scan_request: ScanRequest, background_tasks: BackgroundTasks):
    """Start asynchronous security scan"""
    if not scanner_engine:
        raise HTTPException(status_code=500, detail="Scanner engine not initialized")
    
    # Validate target path
    if not os.path.exists(scan_request.target_path):
        raise HTTPException(status_code=400, detail=f"Target path does not exist: {scan_request.target_path}")

    # Generate scan ID
    scan_id = f"scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    
    # Initialize scan status
    active_scans[scan_id] = {
        "status": "running",
        "progress": 0,
        "message": "Scan initiated",
        "request": scan_request
    }

    # Start background scan task
    background_tasks.add_task(perform_scan, scan_id, scan_request)
    
    return {
        "scan_id": scan_id,
        "message": "Scan started successfully",
        "status_url": f"/scanner/scan/{scan_id}/status"
    }


@app.get("/scanner/scan/{scan_id}/status", response_model=ScanStatus, tags=["Scanning"])
async def get_scan_status(scan_id: str):
    """Get scan status"""
    if scan_id not in active_scans:
        raise HTTPException(status_code=404, detail="Scan ID not found")
    
    scan_info = active_scans[scan_id]
    return ScanStatus(
        scan_id=scan_id,
        status=scan_info["status"],
        progress=scan_info["progress"],
        message=scan_info["message"]
    )


@app.get("/scanner/scan/{scan_id}/result", response_model=ScanResult, tags=["Scanning"])
async def get_scan_result(scan_id: str):
    """Get scan result"""
    if scan_id not in active_scans:
        raise HTTPException(status_code=404, detail="Scan ID not found")
    
    scan_info = active_scans[scan_id]
    
    if scan_info["status"] != "completed":
        raise HTTPException(status_code=202, detail="Scan not completed yet")
    
    if "result" not in scan_info:
        raise HTTPException(status_code=500, detail="Scan result not available")
    
    return scan_info["result"]


@app.get("/scanner/scan/{scan_id}/report", tags=["Reports"])
async def get_scan_report(scan_id: str, format: str = "html", download: bool = False):
    """Get scan report file or HTML content (robust handling + download support)."""
    if scan_id not in active_scans:
        raise HTTPException(status_code=404, detail="Scan ID not found")
    
    scan_info = active_scans[scan_id]
    if scan_info["status"] != "completed":
        raise HTTPException(status_code=202, detail="Scan not completed yet")

    result = scan_info.get("result")
    if not result:
        raise HTTPException(status_code=500, detail="Scan result not available")

    scan_results = {
        "summary": {
            "total": result.total_findings,
            "by_severity": result.severity_summary,
            "by_plugin": {}
        },
        "findings": [
            {
                **f,  # Expand the original data
                "recommendation": f.get("recommendation", "")  # Ensure recommendation is included
            }
            for f in result.findings
        ],
        "scan_info": {
            "target_path": getattr(result, "target_path", ""),
            "timestamp": getattr(result, "scan_time", "").isoformat() if hasattr(getattr(result, "scan_time", None), "isoformat") else str(getattr(result, "scan_time", "")),
            "scanner_version": "2.0.0",
            "stats": {
                "files_scanned": getattr(result, "total_files", 0),
                "plugins_loaded": scanner_engine.stats['plugins_loaded'] if scanner_engine else 0
            }
        }
    }

    try:
        if format.lower() == "html":
            # Prefer the shared renderer (which uses engine raw_result) for identical output
            raw = scan_info.get('raw_result') if isinstance(scan_info, dict) else None
            try:
                if SHARED_RENDERER_AVAILABLE:
                    if raw:
                        html = render_html_report(raw, config_manager=config_manager)
                    else:
                        html = render_html_report(scan_results, config_manager=config_manager)
                elif CLI_HTML_GENERATOR_AVAILABLE:
                    # Fallback to CLI generator if shared renderer isn't available
                    if raw:
                        html = cli_generate_html_report(raw)
                    else:
                        try:
                            html = cli_generate_html_report(scan_results, config_manager=None)
                        except TypeError:
                            html = cli_generate_html_report(scan_results)
                else:
                    # final fallback: Jinja template renderer
                    html = generate_html_report(scan_results)

            except Exception as e:
                # Final fallback to Jinja template render if shared renderer throws
                try:
                    fallback_html = generate_html_report(scan_results)
                    return HTMLResponse(content=fallback_html, media_type='text/html')
                except Exception:
                    raise HTTPException(status_code=500, detail=f'Failed to render report: {e}')

            # If download requested -> ensure a file exists and return as attachment
            if download:
                reports_dir = project_root / "reports"
                reports_dir.mkdir(parents=True, exist_ok=True)
                report_path = reports_dir / f"security_report_{scan_id}.html"
                report_path.write_text(str(html), encoding="utf-8")
                return FileResponse(str(report_path), media_type="text/html", filename=f"security_report_{scan_id}.html")

            # Return inline HTML
            return HTMLResponse(content=str(html), media_type="text/html")

        elif format.lower() == "json":
            report_path = generate_json_report(scan_id, result)
            # support download query param for json as well
            if download:
                return FileResponse(report_path, media_type="application/json", filename=f"security_report_{scan_id}.json")
            else:
                # return file so Swagger can download; browsers may display JSON inline
                return FileResponse(report_path, media_type="application/json", filename=f"security_report_{scan_id}.json")

        else:
            raise HTTPException(status_code=400, detail="Unsupported format. Use 'html' or 'json'")

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to generate report: {str(e)}")


def _unwrap_scan_results(scan_results: dict):
    """Normalize scanner output into fields used by the API."""
    # Get the number of files directly from scan_info
    total_files = scan_results.get("scan_info", {}).get("stats", {}).get("files_scanned")
    
    # If it is not available above, get it from the summary
    if total_files is None:
        total_files = scan_results.get("summary", {}).get("files_scanned")

    # Ensure a valid number is returned
    if total_files is None:
        total_files = 0

    # Get total findings
    total_findings = scan_results.get("summary", {}).get("total")
    if total_findings is None:
        total_findings = len(scan_results.get("findings", []))

    severity_summary = scan_results.get("summary", {}).get("by_severity", {})
    findings = scan_results.get("findings", [])

    return int(total_files), int(total_findings), severity_summary, findings


# --- replace quick_scan ---
@app.post("/scanner/scan/quick", response_model=ScanResult, tags=["Scanning"])
async def quick_scan(scan_request: ScanRequest):
    """Synchronously perform a quick scan (suitable for small projects)"""
    if not scanner_engine:
        raise HTTPException(status_code=500, detail="Scanner engine not initialized")

    if not os.path.exists(scan_request.target_path):
        raise HTTPException(status_code=400, detail=f"Target path does not exist: {scan_request.target_path}")
    
    try:
        scan_results = scanner_engine.scan_target(scan_request.target_path)

        scan_id = f"quick_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

        total_files, total_findings, severity_summary, findings = _unwrap_scan_results(scan_results)

        result = ScanResult(
            scan_id=scan_id,
            target_path=scan_request.target_path,
            scan_time=datetime.now(),
            total_files=total_files,
            total_findings=total_findings,
            severity_summary=severity_summary,
            findings=[
                {
                    "title": f.get("title"),
                    "severity": f.get("severity"),
                    "file_path": f.get("file_path") or f.get("file"),
                    "line_number": f.get("line_number") or f.get("line"),
                    "description": f.get("description") or f.get("match", ""),
                    "plugin_name": f.get("plugin_name") or f.get("plugin"),
                    "recommendation": f.get("recommendation", "")
                }
                for f in findings
            ]
        )

        # store quick scan so /status and /report work
        active_scans[scan_id] = {
            "status": "completed",
            "progress": 100,
            "message": "Quick scan completed",
            "request": scan_request,
            "result": result,
            "raw_result": scan_results
        }

        return result

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Scan failed: {str(e)}")


# --- replace perform_scan ---
async def perform_scan(scan_id: str, scan_request: ScanRequest):
    """Execute background scan task"""
    try:
        active_scans[scan_id]["progress"] = 10
        active_scans[scan_id]["message"] = "Starting scan..."

        scan_results = scanner_engine.scan_target(scan_request.target_path)

        active_scans[scan_id]["progress"] = 80
        active_scans[scan_id]["message"] = "Processing results..."

        total_files, total_findings, severity_summary, findings = _unwrap_scan_results(scan_results)

        result = ScanResult(
            scan_id=scan_id,
            target_path=scan_request.target_path,
            scan_time=datetime.now(),
            total_files=total_files,
            total_findings=total_findings,
            severity_summary=severity_summary,
            findings=[
                {
                    "title": f.get("title"),
                    "severity": f.get("severity"),
                    "file_path": f.get("file_path") or f.get("file"),
                    "line_number": f.get("line_number") or f.get("line"),
                    "description": f.get("description") or f.get("match", ""),
                    "plugin_name": f.get("plugin_name") or f.get("plugin"),
                    "recommendation": f.get("recommendation", "")  # Add a recommendation
                }
                for f in findings
            ]
        )

        # Store the raw scan_results so the API can render reports identical to the CLI
        active_scans[scan_id]["raw_result"] = scan_results

        active_scans[scan_id]["progress"] = 100
        active_scans[scan_id]["status"] = "completed"
        active_scans[scan_id]["message"] = "Scan completed successfully"
        active_scans[scan_id]["result"] = result

    except Exception as e:
        # attach error details to active_scans for debugging
        msg = f"Scan failed: {str(e)}"
        active_scans[scan_id]["status"] = "failed"
        active_scans[scan_id]["message"] = msg
        # optional: keep traceback in logs
        import traceback, logging
        logging.getLogger("scanner_api").error(msg)
        logging.getLogger("scanner_api").error(traceback.format_exc())


# Safe import of jinja2 with fallback flag
try:
    from jinja2 import Environment, FileSystemLoader, select_autoescape
    JINJA_AVAILABLE = True
except Exception:
    JINJA_AVAILABLE = False

# Update template directory configuration (add after import statements at the beginning of the file)
project_root = Path(__file__).parent.parent
TEMPLATE_DIR = project_root / "templates"

def generate_html_report(scan_results: dict) -> str:
    """Generate HTML report from scan results."""
    try:
        env = Environment(
            loader=FileSystemLoader(str(TEMPLATE_DIR)),
            autoescape=select_autoescape(['html', 'xml'])
        )
        template = env.get_template('report.html')

        # Convert findings to ensure recommendations are included
        findings = []
        for f in scan_results.get('findings', []):
            finding = {
                'title': f.get('title', ''),
                'severity': f.get('severity', 'MEDIUM'),
                'file_path': f.get('file_path', ''),
                'line_number': f.get('line_number'),
                'description': f.get('description', ''),
                'plugin_name': f.get('plugin_name', ''),
                'recommendation': f.get('recommendation', '')  # Ensure recommendation is included
            }
            findings.append(finding)
        
        return template.render(
            generated_at=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            scan_info=scan_results.get('scan_info', {}),
            summary=scan_results.get('summary', {}),
            findings=findings  # Use the processed findings
        )
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to generate report: {str(e)}"
        )


def generate_json_report(scan_id: str, result: ScanResult) -> str:
    """Generate a report in JSON format"""
    reports_dir = project_root / "reports"
    reports_dir.mkdir(exist_ok=True)
    
    report_path = reports_dir / f"security_report_{scan_id}.json"
    
    with open(report_path, 'w', encoding='utf-8') as f:
        f.write(result.json(indent=2))
    
    return str(report_path)


if __name__ == "__main__":
    uvicorn.run(
        "scanner_api:app",
        host="0.0.0.0",
        port=8001,
        reload=True,
        log_level="info"
    )