#!/usr/bin/env python3
"""
NutriHelp Security Scanner V2.0 - Core Engine
"""

import os
import sys
import importlib
import logging
from typing import List, Dict, Any, Optional
from pathlib import Path
import uuid
from datetime import datetime

# Add the plugin directory to the Python path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from plugins.base_plugin import BaseSecurityPlugin, PluginManager, SecurityFinding


class SecurityScannerEngine:
    """Security Scanner Engine Core Class"""

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.plugin_manager = PluginManager()
        self.logger = logging.getLogger("SecurityScannerEngine")
        self._setup_logging()

        # Statistics
        self.stats = {
            'files_scanned': 0,
            'total_findings': 0,
            'plugins_loaded': 0
        }
    
    def _setup_logging(self):
        """Set up logging configuration"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.StreamHandler(),
                # can add file processors
            ]
        )
    
    def load_plugins(self, plugin_configs: Optional[Dict[str, Any]] = None):
        """Dynamically load plugins"""
        plugin_configs = plugin_configs or {}
        plugins_loaded = 0

        # Define plugin mappings
        plugin_mappings = {
            'jwt_missing_protection': 'plugins.jwt_security.jwt_missing',
            'jwt_configuration': 'plugins.jwt_security.jwt_config',
            # General security plugin
            'general_security': 'plugins.general_security',
            # RLS plugin removed to fix dependency issues
        }
        
        for plugin_name, module_path in plugin_mappings.items():
            plugin_config = plugin_configs.get(plugin_name, {})
            
            # Check if the plugin is enabled
            if not plugin_config.get('enabled', True):
                self.logger.info(f"Plugin {plugin_name} is disabled")
                continue
            
            try:
                # Dynamically import plugin module
                module = importlib.import_module(module_path)

                # Find plugin class (convention: ends with Plugin)
                plugin_class = None
                for attr_name in dir(module):
                    attr = getattr(module, attr_name)
                    if (isinstance(attr, type) and 
                        issubclass(attr, BaseSecurityPlugin) and 
                        attr != BaseSecurityPlugin):
                        plugin_class = attr
                        break
                
                if plugin_class:
                    plugin_instance = plugin_class(plugin_config.get('config', {}))
                    self.plugin_manager.register_plugin(plugin_instance)
                    plugins_loaded += 1
                else:
                    self.logger.warning(f"No plugin class found in {module_path}")
                    
            except ImportError as e:
                self.logger.warning(f"Could not load plugin {plugin_name}: {e}")
            except Exception as e:
                self.logger.error(f"Error loading plugin {plugin_name}: {e}")
        
        self.stats['plugins_loaded'] = plugins_loaded
        self.logger.info(f"Loaded {plugins_loaded} plugins")
    
    def _count_by_severity(self, findings: List[Any]) -> Dict[str, int]:
        """Count findings by severity level."""
        severity_counts = {}
        for finding in findings:
            # Handle both object and dict findings
            if hasattr(finding, 'severity'):
                severity = finding.severity
            else:
                severity = finding.get('severity', 'UNKNOWN')
            
            severity = str(severity).upper()
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        return severity_counts

    def _count_by_plugin(self, findings: List[Any]) -> Dict[str, int]:
        """Count findings by plugin name."""
        plugin_counts = {}
        for finding in findings:
            # Handle both object and dict findings
            if hasattr(finding, 'plugin'):
                plugin = finding.plugin
            else:
                plugin = finding.get('plugin', 'Unknown')
            
            plugin_counts[plugin] = plugin_counts.get(plugin, 0) + 1
        return plugin_counts

    def scan_target(self, target_path: str) -> Dict:
        """Run all security plugins on the target."""
        self.logger.info(f"Starting security scan on: {target_path}")
        all_findings = []
    
        # Make sure to count the number of files first
        files_scanned = self._count_scannable_files(target_path)
        self.stats['files_scanned'] = files_scanned
    
        for plugin in self.plugin_manager.plugins:
            try:
                findings = plugin.scan(target_path)
                if findings:
                    # Process each finding
                    for finding in findings:
                        # Prefer plugin-provided recommendation; generate only if missing/empty
                        existing_rec = None
                        if hasattr(finding, 'recommendation'):
                            existing_rec = getattr(finding, 'recommendation')
                        elif isinstance(finding, dict):
                            existing_rec = finding.get('recommendation')

                        if not existing_rec:
                            # Generate and add recommendation only when plugin didn't provide one
                            recommendation = self._generate_recommendation(
                                finding.title if hasattr(finding, 'title') else finding.get('title', ''),
                                finding.file_path if hasattr(finding, 'file_path') else finding.get('file_path', '')
                            )

                            # If finding is an object
                            if hasattr(finding, 'recommendation'):
                                finding.recommendation = recommendation
                            # If finding is a dictionary
                            elif isinstance(finding, dict):
                                finding['recommendation'] = recommendation

                        # Ensure other attributes exist
                        if hasattr(finding, 'plugin') and not getattr(finding, 'plugin', None):
                            finding.plugin = plugin.__class__.__name__
                        if hasattr(finding, 'file_path') and not getattr(finding, 'file_path', None):
                            finding.file_path = target_path

                    all_findings.extend(findings)
            except Exception as e:
                self.logger.error(f"Plugin {plugin.__class__.__name__} failed: {e}")

        # Convert findings to ensure recommendations are included
        findings_dict = []
        for f in all_findings:
            if hasattr(f, 'to_dict'):
                finding_dict = f.to_dict()
                # Ensure recommendation is included in the dictionary
                if hasattr(f, 'recommendation'):
                    finding_dict['recommendation'] = f.recommendation
                findings_dict.append(finding_dict)
            else:
                findings_dict.append(f)
    
        return {
            'scan_id': str(uuid.uuid4()),
            'target': target_path,
            'timestamp': datetime.now().isoformat(),
            'findings': findings_dict,  # Use the processed findings
            'summary': {
                'total': len(all_findings),
                'files_scanned': files_scanned,
                'by_severity': self._count_by_severity(all_findings),
                'by_plugin': self._count_by_plugin(all_findings)
            },
            'scan_info': {
                'target_path': target_path,
                'scanner_version': "2.0.0",
                'stats': {
                    'files_scanned': files_scanned,
                    'plugins_loaded': len(self.plugin_manager.plugins),
                    'total_findings': len(all_findings)
                }
            }
        }
    
    def _count_scannable_files(self, target_path: str) -> int:
        """Count scannable files"""
        count = 0
        for root, dirs, files in os.walk(target_path):
            # Skip directories that should not be scanned
            dirs[:] = [d for d in dirs if not self._should_skip_dir(os.path.join(root, d))]
            
            for file in files:
                file_path = os.path.join(root, file)
                if self._is_scannable_file(file_path):
                    count += 1
        return count
    
    def _should_skip_dir(self, dir_path: str) -> bool:
        """Check if a directory should be skipped"""
        skip_dirs = self.config.get('exclude_directories', [
            'node_modules', '.git', '__pycache__', 'venv', '.venv', 
            'dist', 'build', 'uploads'
        ])
        dir_name = os.path.basename(dir_path)
        return dir_name in skip_dirs
    
    def _is_scannable_file(self, file_path: str) -> bool:
        """Check if a file is scannable"""
        supported_extensions = self.config.get('file_extensions', [
            '.js', '.ts', '.py', '.sql', '.json', '.yaml', '.yml'
        ])
        file_ext = os.path.splitext(file_path)[1].lower()
        return file_ext in supported_extensions
    
    def _generate_summary(self, findings: List[SecurityFinding]) -> Dict[str, Any]:
        """Generate scan summary"""
        summary = {
            'total': len(findings),
            'by_severity': {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0},
            'by_plugin': {}
        }
        
        for finding in findings:
            # Count by severity
            severity = finding.severity.upper()
            if severity in summary['by_severity']:
                summary['by_severity'][severity] += 1

            # Count by plugin
            plugin_name = finding.plugin or 'Unknown'
            if plugin_name not in summary['by_plugin']:
                summary['by_plugin'][plugin_name] = 0
            summary['by_plugin'][plugin_name] += 1
        
        return summary
    
    def _get_timestamp(self) -> str:
        """Get timestamp"""
        from datetime import datetime
        return datetime.now().isoformat()
    
    def get_scan_stats(self) -> Dict[str, Any]:
        """Get scan statistics"""
        return self.stats.copy()

    def _generate_recommendation(self, finding_type: str, file_path: str) -> str:
        """Generate specific recommendations based on finding type."""
        # Return a structured recommendation dict
        if "JWT" in finding_type:
            return {
                'summary': 'Add JWT authentication middleware to the route.',
                'steps': [
                    "Import the middleware if missing: const { authenticateToken } = require('../middleware/authenticateToken');",
                    "Add middleware to the route: e.g. router.post('/', authenticateToken, (req, res) => { ... });",
                    "Consider optional authentication helper if needed: const { optionalAuth } = require('../middleware/authenticateToken');",
                    "Verify token lifetimes and error handling policies."
                ],
                'code': "const { authenticateToken } = require('../middleware/authenticateToken');\nrouter.post('/', authenticateToken, (req, res) => { ... });"
            }
        
        # Add more recommendation types as needed
        return {
            'summary': 'Review this finding and apply best-practice remediation steps.',
            'steps': ["Investigate the issue details.", "Apply an appropriate fix and test."],
            'code': ''
        }